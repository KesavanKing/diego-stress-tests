package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type LogLineData struct {
	Timestamp string  `json:"timestamp"`
	Source    string  `json:"source"`
	Message   string  `json:"message"`
	Log_level int     `json:"log_level"`
	Data      LogData `json:"data"`
}

type LogData struct {
	Session  string `json:"session"`
	Interval string `json:"inteval"`
}

var inputFilePath = flag.String(
	"inputFilePath",
	"",
	"Path to the input log file",
)

var outputFilePath = flag.String(
	"outputFilePath",
	"output.data",
	"Path to the output log file",
)

func main() {
	flag.Parse()

	file, err := os.Open(*inputFilePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	mapper := make(map[string]*LogLineData)

	for scanner.Scan() {
		var logLine LogLineData
		line := scanner.Text()
		println("------------------\n" + line)
		json.Unmarshal([]byte(line), &logLine)
		mapData(mapper, logLine)
	}

	if err := scanner.Err(); err != nil {
		panic(err)
	}
}

func mapData(mapper map[string]*LogLineData, log LogLineData) error {

	if !isHandler(log) {
		return fmt.Errorf("not a handler")
	}

	fmt.Printf("Timestamp %#s\n", log.Timestamp)
	fmt.Printf("Data %#v\n", log)

	sessionId := log.Data.Session
	if _, ok := mapper[sessionId]; !ok {
		mapper[sessionId] = &log
	} else {
		endTime, err := strconv.ParseFloat(log.Timestamp, 64)
		if err != nil {
			panic(err)
		}

		startTime, err := strconv.ParseFloat(mapper[sessionId].Timestamp, 64)
		if err != nil {
			panic(err)
		}

		timeDiff := endTime - startTime
		fmt.Printf("\t TimeDiff %v\n", timeDiff)
		fmt.Printf("\t Session  %s\n\n", log.Data.Session)
	}
	return nil
}

func isHandler(log LogLineData) bool {
	return strings.Contains(log.Message, "handler")
}
