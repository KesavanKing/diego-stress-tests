// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/diego-stress-tests/cedar/config"
)

type FakeConfig struct {
	NumBatchesStub        func() int
	numBatchesMutex       sync.RWMutex
	numBatchesArgsForCall []struct{}
	numBatchesReturns     struct {
		result1 int
	}
	MaxInFlightStub        func() int
	maxInFlightMutex       sync.RWMutex
	maxInFlightArgsForCall []struct{}
	maxInFlightReturns     struct {
		result1 int
	}
	MaxPollingErrorsStub        func() int
	maxPollingErrorsMutex       sync.RWMutex
	maxPollingErrorsArgsForCall []struct{}
	maxPollingErrorsReturns     struct {
		result1 int
	}
	AppPayloadStub        func() string
	appPayloadMutex       sync.RWMutex
	appPayloadArgsForCall []struct{}
	appPayloadReturns     struct {
		result1 string
	}
	PrefixStub        func() string
	prefixMutex       sync.RWMutex
	prefixArgsForCall []struct{}
	prefixReturns     struct {
		result1 string
	}
	DomainStub        func() string
	domainMutex       sync.RWMutex
	domainArgsForCall []struct{}
	domainReturns     struct {
		result1 string
	}
	OutputFileStub        func() string
	outputFileMutex       sync.RWMutex
	outputFileArgsForCall []struct{}
	outputFileReturns     struct {
		result1 string
	}
	TimeoutStub        func() time.Duration
	timeoutMutex       sync.RWMutex
	timeoutArgsForCall []struct{}
	timeoutReturns     struct {
		result1 time.Duration
	}
	TotalAppCountStub        func() int
	totalAppCountMutex       sync.RWMutex
	totalAppCountArgsForCall []struct{}
	totalAppCountReturns     struct {
		result1 int
	}
	MaxAllowedFailuresStub        func() int
	maxAllowedFailuresMutex       sync.RWMutex
	maxAllowedFailuresArgsForCall []struct{}
	maxAllowedFailuresReturns     struct {
		result1 int
	}
	AppTypesStub        func() []config.AppDefinition
	appTypesMutex       sync.RWMutex
	appTypesArgsForCall []struct{}
	appTypesReturns     struct {
		result1 []config.AppDefinition
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) NumBatches() int {
	fake.numBatchesMutex.Lock()
	fake.numBatchesArgsForCall = append(fake.numBatchesArgsForCall, struct{}{})
	fake.recordInvocation("NumBatches", []interface{}{})
	fake.numBatchesMutex.Unlock()
	if fake.NumBatchesStub != nil {
		return fake.NumBatchesStub()
	} else {
		return fake.numBatchesReturns.result1
	}
}

func (fake *FakeConfig) NumBatchesCallCount() int {
	fake.numBatchesMutex.RLock()
	defer fake.numBatchesMutex.RUnlock()
	return len(fake.numBatchesArgsForCall)
}

func (fake *FakeConfig) NumBatchesReturns(result1 int) {
	fake.NumBatchesStub = nil
	fake.numBatchesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) MaxInFlight() int {
	fake.maxInFlightMutex.Lock()
	fake.maxInFlightArgsForCall = append(fake.maxInFlightArgsForCall, struct{}{})
	fake.recordInvocation("MaxInFlight", []interface{}{})
	fake.maxInFlightMutex.Unlock()
	if fake.MaxInFlightStub != nil {
		return fake.MaxInFlightStub()
	} else {
		return fake.maxInFlightReturns.result1
	}
}

func (fake *FakeConfig) MaxInFlightCallCount() int {
	fake.maxInFlightMutex.RLock()
	defer fake.maxInFlightMutex.RUnlock()
	return len(fake.maxInFlightArgsForCall)
}

func (fake *FakeConfig) MaxInFlightReturns(result1 int) {
	fake.MaxInFlightStub = nil
	fake.maxInFlightReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) MaxPollingErrors() int {
	fake.maxPollingErrorsMutex.Lock()
	fake.maxPollingErrorsArgsForCall = append(fake.maxPollingErrorsArgsForCall, struct{}{})
	fake.recordInvocation("MaxPollingErrors", []interface{}{})
	fake.maxPollingErrorsMutex.Unlock()
	if fake.MaxPollingErrorsStub != nil {
		return fake.MaxPollingErrorsStub()
	} else {
		return fake.maxPollingErrorsReturns.result1
	}
}

func (fake *FakeConfig) MaxPollingErrorsCallCount() int {
	fake.maxPollingErrorsMutex.RLock()
	defer fake.maxPollingErrorsMutex.RUnlock()
	return len(fake.maxPollingErrorsArgsForCall)
}

func (fake *FakeConfig) MaxPollingErrorsReturns(result1 int) {
	fake.MaxPollingErrorsStub = nil
	fake.maxPollingErrorsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) AppPayload() string {
	fake.appPayloadMutex.Lock()
	fake.appPayloadArgsForCall = append(fake.appPayloadArgsForCall, struct{}{})
	fake.recordInvocation("AppPayload", []interface{}{})
	fake.appPayloadMutex.Unlock()
	if fake.AppPayloadStub != nil {
		return fake.AppPayloadStub()
	} else {
		return fake.appPayloadReturns.result1
	}
}

func (fake *FakeConfig) AppPayloadCallCount() int {
	fake.appPayloadMutex.RLock()
	defer fake.appPayloadMutex.RUnlock()
	return len(fake.appPayloadArgsForCall)
}

func (fake *FakeConfig) AppPayloadReturns(result1 string) {
	fake.AppPayloadStub = nil
	fake.appPayloadReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Prefix() string {
	fake.prefixMutex.Lock()
	fake.prefixArgsForCall = append(fake.prefixArgsForCall, struct{}{})
	fake.recordInvocation("Prefix", []interface{}{})
	fake.prefixMutex.Unlock()
	if fake.PrefixStub != nil {
		return fake.PrefixStub()
	} else {
		return fake.prefixReturns.result1
	}
}

func (fake *FakeConfig) PrefixCallCount() int {
	fake.prefixMutex.RLock()
	defer fake.prefixMutex.RUnlock()
	return len(fake.prefixArgsForCall)
}

func (fake *FakeConfig) PrefixReturns(result1 string) {
	fake.PrefixStub = nil
	fake.prefixReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Domain() string {
	fake.domainMutex.Lock()
	fake.domainArgsForCall = append(fake.domainArgsForCall, struct{}{})
	fake.recordInvocation("Domain", []interface{}{})
	fake.domainMutex.Unlock()
	if fake.DomainStub != nil {
		return fake.DomainStub()
	} else {
		return fake.domainReturns.result1
	}
}

func (fake *FakeConfig) DomainCallCount() int {
	fake.domainMutex.RLock()
	defer fake.domainMutex.RUnlock()
	return len(fake.domainArgsForCall)
}

func (fake *FakeConfig) DomainReturns(result1 string) {
	fake.DomainStub = nil
	fake.domainReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) OutputFile() string {
	fake.outputFileMutex.Lock()
	fake.outputFileArgsForCall = append(fake.outputFileArgsForCall, struct{}{})
	fake.recordInvocation("OutputFile", []interface{}{})
	fake.outputFileMutex.Unlock()
	if fake.OutputFileStub != nil {
		return fake.OutputFileStub()
	} else {
		return fake.outputFileReturns.result1
	}
}

func (fake *FakeConfig) OutputFileCallCount() int {
	fake.outputFileMutex.RLock()
	defer fake.outputFileMutex.RUnlock()
	return len(fake.outputFileArgsForCall)
}

func (fake *FakeConfig) OutputFileReturns(result1 string) {
	fake.OutputFileStub = nil
	fake.outputFileReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Timeout() time.Duration {
	fake.timeoutMutex.Lock()
	fake.timeoutArgsForCall = append(fake.timeoutArgsForCall, struct{}{})
	fake.recordInvocation("Timeout", []interface{}{})
	fake.timeoutMutex.Unlock()
	if fake.TimeoutStub != nil {
		return fake.TimeoutStub()
	} else {
		return fake.timeoutReturns.result1
	}
}

func (fake *FakeConfig) TimeoutCallCount() int {
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	return len(fake.timeoutArgsForCall)
}

func (fake *FakeConfig) TimeoutReturns(result1 time.Duration) {
	fake.TimeoutStub = nil
	fake.timeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) TotalAppCount() int {
	fake.totalAppCountMutex.Lock()
	fake.totalAppCountArgsForCall = append(fake.totalAppCountArgsForCall, struct{}{})
	fake.recordInvocation("TotalAppCount", []interface{}{})
	fake.totalAppCountMutex.Unlock()
	if fake.TotalAppCountStub != nil {
		return fake.TotalAppCountStub()
	} else {
		return fake.totalAppCountReturns.result1
	}
}

func (fake *FakeConfig) TotalAppCountCallCount() int {
	fake.totalAppCountMutex.RLock()
	defer fake.totalAppCountMutex.RUnlock()
	return len(fake.totalAppCountArgsForCall)
}

func (fake *FakeConfig) TotalAppCountReturns(result1 int) {
	fake.TotalAppCountStub = nil
	fake.totalAppCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) MaxAllowedFailures() int {
	fake.maxAllowedFailuresMutex.Lock()
	fake.maxAllowedFailuresArgsForCall = append(fake.maxAllowedFailuresArgsForCall, struct{}{})
	fake.recordInvocation("MaxAllowedFailures", []interface{}{})
	fake.maxAllowedFailuresMutex.Unlock()
	if fake.MaxAllowedFailuresStub != nil {
		return fake.MaxAllowedFailuresStub()
	} else {
		return fake.maxAllowedFailuresReturns.result1
	}
}

func (fake *FakeConfig) MaxAllowedFailuresCallCount() int {
	fake.maxAllowedFailuresMutex.RLock()
	defer fake.maxAllowedFailuresMutex.RUnlock()
	return len(fake.maxAllowedFailuresArgsForCall)
}

func (fake *FakeConfig) MaxAllowedFailuresReturns(result1 int) {
	fake.MaxAllowedFailuresStub = nil
	fake.maxAllowedFailuresReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) AppTypes() []config.AppDefinition {
	fake.appTypesMutex.Lock()
	fake.appTypesArgsForCall = append(fake.appTypesArgsForCall, struct{}{})
	fake.recordInvocation("AppTypes", []interface{}{})
	fake.appTypesMutex.Unlock()
	if fake.AppTypesStub != nil {
		return fake.AppTypesStub()
	} else {
		return fake.appTypesReturns.result1
	}
}

func (fake *FakeConfig) AppTypesCallCount() int {
	fake.appTypesMutex.RLock()
	defer fake.appTypesMutex.RUnlock()
	return len(fake.appTypesArgsForCall)
}

func (fake *FakeConfig) AppTypesReturns(result1 []config.AppDefinition) {
	fake.AppTypesStub = nil
	fake.appTypesReturns = struct {
		result1 []config.AppDefinition
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.numBatchesMutex.RLock()
	defer fake.numBatchesMutex.RUnlock()
	fake.maxInFlightMutex.RLock()
	defer fake.maxInFlightMutex.RUnlock()
	fake.maxPollingErrorsMutex.RLock()
	defer fake.maxPollingErrorsMutex.RUnlock()
	fake.appPayloadMutex.RLock()
	defer fake.appPayloadMutex.RUnlock()
	fake.prefixMutex.RLock()
	defer fake.prefixMutex.RUnlock()
	fake.domainMutex.RLock()
	defer fake.domainMutex.RUnlock()
	fake.outputFileMutex.RLock()
	defer fake.outputFileMutex.RUnlock()
	fake.timeoutMutex.RLock()
	defer fake.timeoutMutex.RUnlock()
	fake.totalAppCountMutex.RLock()
	defer fake.totalAppCountMutex.RUnlock()
	fake.maxAllowedFailuresMutex.RLock()
	defer fake.maxAllowedFailuresMutex.RUnlock()
	fake.appTypesMutex.RLock()
	defer fake.appTypesMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.Config = new(FakeConfig)
